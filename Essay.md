# Реферат 
## по курсу "Логическое программирование"

### студент: Макаров В.А.

## Логические языки как путь к автоматическому решению задач компьютером

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Вступление

На данный момент, программисты и математики добились заметных успехов в автоматизации решения многих задач. Мы постоянно стремимся уменьшить участие специалистов в вычислениях, и это проявляется во многих вещах. Например, в особенностях какого-либо языка программирования - хорошей иллюстрацией служат декларативные языки, в которых задача программиста – ввести в нужном виде имеющиеся факты, затем задать к ним запрос, а программа автоматически проанализирует данные и выдаст ответ. Или целое направление в программировании, занимающееся искусственным интеллектом.  

Как компьютеру научиться автоматически решать задачи? Для начала разберемся в том, из чего состоит задача, и какими способами компьютер может ее решить. Почти любая задача состоит из 3 компонент: исходные данные, способы их преобразования, и поставленный вопрос. Однако, не на все задачи компьютер может сразу дать корректный ответ.

В случае, если мы имеем дело с простой задачей, нам уже перед началом ее решения понятно какой ход мыслей у нас будет, и какой примерно ответ мы хотим получить. В качестве известного примера подобных задач вспомним задачу Эйнштейна. У нас есть четко определенный набор фактов, мы четко понимаем какие запросы к компьютеру надо совершить, чтобы решить эту задачу. Главное - мы уверены в однозначности ответа. То есть при корректно построенном условии мы гарантировано получим достоверный ответ. Здесь мы видим тривиальный пример автоматического решения компьютером несложной задачи, в которой мы действуем в предсказуемых условиях и получаем предсказуемый и однозначный ответ. Однако подобные задачи не представляют особого научного интереса, и чаще всего применяются для автоматизации каких-либо несложных задач на большом количестве данных.

Гораздо более актуальная и интересная категория – задачи, в которых компьютер не может в любом случае предоставить гарантированно правильный ответ. Например, задачи, связанные с машинным зрением. Даже хорошо обученная на тысячах примеров нейросеть не всегда будет показывать идеально-правильный ответ. Для решения подобных задач применяются техники машинного обучения и построения нейросетей. В данном эссе мы не будем углубляться в работу искусственного интеллекта или машинного обучения, а посмотрим, как логические языки могут помочь нам в их составлении.

## Почему логические языки?
Сначала стоит сказать пару слов об основных преимуществах логических языков в целом.
Главная задача программиста в любом логическом языке – описать логическую модель, набор фактов, и базовые правила отношений между ними. Главная цель программы – вывод новых фактов из набора имеющихся фактов путем заданных логических правил. 

Поскольку логические языки основаны на логике предикатов и на базовых правилах дискретной математики, нам удобно работать со структурированной информацией, то есть описывать отношения между объектами, имеющими схожую структуру. Из этого мы можем сделать вывод о том, что логические языки хорошо подходят для обработки реляционных моделей.

Еще одна причина – встроенные в языки возможности перебора решений и бэктрекинга, которые позволяют без дополнительных описаний алгоритмов автоматически перебирать все возможные варианты, и находить решения. Это значит, что мы можем лаконично и понятно реализовать алгоритмы поиска решений в графах, операции со списками и рекурсивные алгоритмы.
Далее мы увидим, как эти особенности помогут нам в конструировании более сложных программ, и почему они могут стать первой ступенью к автоматизации решения задач компьютером.

## Базы знаний на языке Пролог
Как писал в своем учебнике по искусственному интеллекту [1] профессор Техасского технологического университета Майкл Гельфонд: «Если мы хотим разработать программу, способную разумно вести себя в некоторой среде, нам необходимо предоставить программе максимум информации об этой среде. Для этого нам нужен такой язык программирования, на котором удобнее всего будет составить список известных фактов, а также описать точные и понятные взаимоотношения между этими фактами. К тому же, составленная нами база данных, должна быть толерантна к разработке (elaboration tolerant), то есть изменяя какой-либо факт, мы не воздействуем на остальную базу данных.» (не дословный перевод с англ.)

В 1960 году Джон Маккарти предложил использовать формулы логики предикатов в качестве основы для работы с фактами и их представления. Однако позже у этой идеи нашлось много недостатков, в основном, при моделировании рассуждений в сложных программах. Таким образом, началась работа над логическими языками с немонотонными отношениями, то есть допускающие опро вержение предыдущих выводов новыми знаниями. Трое ученых: Грин, Колмероэ и Ковальский совместили идеи Маккарти об использовании логических формул для представления знаний, а также теорию автоматической дедукции и конструктивной логики. Это привело их к созданию такого направления как логическое программирование и разработке логического языка Prolog. 

Таким образом, заглянув в историю, мы убеждаемся, что в основе любой интеллектуальной системы всегда лежит определенный набор заранее известных фактов, или же фактов, полученных программой ранее (в самообучающихся системах). Этот набор фактов называется базой знаний, и полностью определяет результат работы любой программы, обращающейся к этой базе.
Пролог позволяет конструировать наглядные базы знаний, описывающий почти любой тип объектов. 

Например, представив в виде реляционной модели:
```Prolog
animal('Elephant', grey, big, mammal).
…
student('Иван Иванов', 'г.Иваново','ул.Иванова','д.1','кв.1').
…
```
И в дальнейшем мы сможем обращаться к этим объектам, получая информацию о любом поле заданного объекта. 

Еще один способ задать базу знаний – семантические сети. [2] По сути, реализация семантической сети на логическом языке – описание ориентированного графа путем перечисления всех отношений между его вершинами.

Тривиальный пример семантической сети.
```Prolog
it_is(andrew, human).
it_is(rick, human).
it_is(kitty, cat).
it_is(milly, cat).
it_is(cat, pet).
it_is(pet, animal).
it_is(mammal, animal).
it_is(cat, mammal).
it_is(human, mammal).
```
Здесь описаны все вершины графа, и существующие пути. В качестве простого примера работы с такой структурой напишем простейший предикат, проверяющий, принадлежат ли существа с данными именами к одному виду.
```Prolog
these_names_are_same_creatures(X,Y) :- 
    it_is(X,Creature), it_is(Y,Creature), 
    not(X==Y), 
    it_is(Creature,Type), it_is(Type,_).
_________________
?- these_names_are_same_creatures(andrew,kitty).
false
?- these_names_are_same_creatures(andrew,rick).
true
```
Попробовав реализовать некоторые базы знаний, можно убедиться в том, насколько логические языки подходят для таких задач. Запись фактов в них максимально наглядна и легко редактируется.

## Логические языки в экспертных системах
Перед тем как вспомнить о настоящем искусственном интеллекте и нейросетях, стоит упомянуть более узкую область программирования – экспертные системы. Довольно известный пример – популярное в свое время, особенно в США, приложение «Домашний Доктор».

Пользователь отвечал на набор вопросов, в результате чего получал предполагаемый характер заболевания.  Также экспертные системы распространены в военном деле, электронике, химии и многих других областях.

По сути, экспертная система это объемный структурированный набор знаний, полученных экспертами в той или иной области и записанный в удобной для анализа форме, и набор инструментов для их обработки и принятия некоторого решения. [3] Стоит отметить, что экспертные системы не производят полное автоматическое решение задачи, а только анализируют данные, и на основе некоторого опыта эксперта дают ему совет. Для этого необходимо сначала составить некоторую базу знаний. То есть с помощью специального человека – инженера по знаниям и работающего с ним эксперта необходимо структурировать имеющиеся знания по некоторой теме в виде формализованных правил. Получается, что экспертная система не может полностью заменить хорошего эксперта, но может помочь ему решить задачу быстрого анализа накопленных ранее знаний.

Возникает вопрос – как лучше структурировать имеющиеся знания в базу знаний? На практике, чаще всего, удобнее будет начать с бинарного дерева решений, то есть, поскольку эксперт, очевидно не сможет просто перечислить все возможные правила, мы задаем ему вопросы, и на их основе составляем дерево. Именно эта структура удачно моделирует рассуждения эксперта. Затем, если это необходимо, преобразовать такое дерево в дерево типа И/ИЛИ, по которому уже составлять наборы правил, по которым уже делать логический вывод.

Таким образом, составляя базу знаний, мы получаем некоторый граф состояний, вершинами которого будут некоторые состояния (рабочая память), а ребрами – правила перехода между состояниями.  
Во-первых, стоит отметить опциональность реализации работы с таким деревом. Например, в зависимости от цели программы и конструкции базы знаний, мы можем использовать как прямой, так и обратный порядок вывода, иначе говоря, идти либо от фактов к заключениям (как, например, во многих медицинских системах) либо сначала выдвинуть некоторую гипотезу, а затем, проверяя факты, подтвердить или опровергнуть ее. В любом случае, мы так или иначе столкнемся с необходимостью выполнить поиск решения в графе. 

Здесь нам и помогут логические языки программирования, поскольку, как мы знаем, они хорошо подходят для таких операций. Мы можем реализовать различные алгоритмы поиска, однако, очевидно, что не все алгоритмы будут одинаково эффективны, например, при поиске в ширину, программа будет слишком ресурсозатратной, поскольку для хороших экспертных систем характерен большой объем данных. Одним из оптимальных алгоритмов можно считать поиск в глубину.

Еще один важный аспект – удобный трейсинг программ в логических языках. То есть, получив от экспертной системы какой-либо результат, мы всегда можем проследить путь от запроса к получению этого результата. В этом, кстати, заключается одно из преимуществ экспертных систем над нейросетями.

## KNN-алгоритм
Рассмотрим один из самых простых и известных алгоритмов, применяемый для некоторых задач машинного обучения – алгоритм поиска k - ближайших соседей (K Nearest Neighbours). [4] Сам по себе, алгоритм выполняет задачу классификации, то есть распределения объекта в один из описанных в программе классов на основе некоторых его свойств. Метод не универсален для всех типов задач, поскольку для его реализации, мы предполагаем, что схожие между собой объекты находятся в пространстве «группами», то есть ближайшие элементы, вероятно, принадлежат одному классу.

Суть алгоритма проста – у нас есть набор объектов, каждый из которых принадлежит к какому-либо классу. 

Далее нам необходимо определить понятие расстояния между объектами. Например, в самой популярной иллюстрации данного алгоритма демонстрируется плоскость, на которой отмечены точки разных цветов. Соответственно, цвет точки – это ее класс. В этом случае понятие расстояния можно считать очевидным – достаточно тривиальной реализации евклидовой метрики. Но, можно заметить, что не всегда возможно вычислить расстояние подобным путем, поскольку исходные данные могут быть представлены в любом формате. Например, как было сказано ранее, база знаний может быть представлена в виде нагруженного графа. Тогда расстояние между двумя элементами соответствует значению ребра графа. В любом случае, почти всегда для любых двух элементов одного класса можно ввести собственную метрику. Это применимо даже для целых текстовых блоков. Для этого была разработана векторная модель семантики, в частности, такая структура как матрица термин-документ. То есть, говоря обобщенно - для большинства конкретных задач можно ввести собственную метрику, значения которой должны принадлежать множеству, на котором реализованы отношения сравнения двух любых элементов. 

Итак, имея набор объектов и определенную для них метрику, мы должны, получив новый объект, определить к какому классу он относится. Для этого вводим целое число k (оптимальное число k вычисляется, как раз, в ходе машинного обучения). Выбираем k ближайших к новому объекту элементов. Смотрим на их классы и ищем самый часто встречаемый. Полагаем, что новый объект относится к этому классу.

Итак, чем логические языки помогут в реализации данного алгоритма?

Главное – это, конечно, в формировании базы знаний. Это было не раз упомянуто в данной работе, и является одним из основных преимуществ логических языков.
Для формирования базы нужно задать существующие объекты путем их простого перечисления. Для этого в языке Пролог реализована удобная система фактов и правил. Запись фактов будет идентична для любой задачи. Приведем примеры:
```Prolog
person('Сергей',21,student).
person('Алексей',43,employee).

point(0,0,red).
point(1,1,blue).
```
Здесь объекты person задаются именем и возрастом и имеют класс с названием их профессии. Объекты points заданы координатами на плоскости, и имеют класс с их цветом.
Введем метрику:
```Prolog
distance_persons(person(_,Age1,_),person(_,Age2,_),D) :- 
    D is abs(Age1 - Age2).

distance_points(point(Ax, Ay,_), point(Bx, By,_), D):-
  Dx is abs(Ax-Bx),
  Dy is abs(Ay-By),
  D is sqrt(Dx*Dx+Dy*Dy), !.
```  
Таким образом, расстояние для двух точек определяется по теореме Пифагора, а для двух людей, один из вариантов - по их возрасту.

Не углубляясь в написание кода, но проговаривая идеи главных алгоритмов, разберемся почему логические языки, в частности Пролог, удобны для работы с такими данными.

Как мы знаем, Пролог постоянно выполняет, в некотором смысле, поиск решений. Мы задаем некоторое правило, и с помощью унификации и бэктрекинга выполняем поиск фактов, удовлетворяющих правилу. В алгоритме KNN первый же поиск, который нам предстоит выполнить – поиск K ближайших элементов. Пролог обладает достаточным аппаратом для реализации  этой задачи. Например, на прологе реализуемы алгоритмы сортировки - для решения задачи нам потребуется сортировать список всех элементов, в зависимости от дистанции от заданного. Это также можно легко реализовать в любом логическом языке. Для этого, на этапе когда мы сравниваем два элемента, чтобы узнать какой из них больше, мы вызываем предикат поиска дистанции этого элемента от заданного, и сравниваем результаты этих предикатов вместо самих объектов. После этог нам нужно взять первые K элементов из отсортированного по возрастанию массива. Это и будут K ближайших элементов. Затем, путем унификации полученных элементов с фактами из базы знаний, узнаем их класс, добавляя классы в новый список. Затем, подсчитываем количество каждого класса в списке, и выбираем самый часто втречаемый. Соответственно, алгоритм завершен, и мы получили значение класса для новой точки.

На примере алгоритма KNN, как алгоритма, применяемого в машинном обучении, мы увидели эффективность и наглядность записи данных в логическом языке. Все данные об элементе удобно записаны в виде фактов, и любую информацию можно получить, обратившись к соответствующему полю элемента.
## Выводы
В течение семестра я изучал язык Пролог, поэтому, подводя итоги, буду упоминать его. Однако, следующие слова относятся почти ко всем логическим языкам.

Итак, главная мысль, которая была описана в данной работе - все передовые технологии по автоматизации решения задач компьютером требуют описания имеющихся знаний в той или иной области. Конечно, базы знаний можно реализовать на любом языке программирования, но для работы с ними нам придется написать целый ряд алгоритмов даже для элементарных базовых действий по ее анализу. Например, для поиска необходимой информации о каком-то объекте, нам потребуется вручную писать алгоритм, перебирающий все объекты, пока не будет найден нужный, и затем производящий поиск этой информации в описании объекта. И даже реализовав этот, мы не всегда будем уверены, что программа написана корректно (например, из-за случайной ошибки программиста). В Прологе такая проблема в принципе отсутствует. Основной механизм Пролога - унификация, автоматически выполняет поиск объекта, сопоставляя входные данные с общей базой. При этом, если мы правильно составили базу - у нас исключена вероятность ошибки. Поскольку Пролог - язык, основанный на Хорновских дизъюнктах - подмножестве логики предикатов первого порядка, он, как и многие логические языки, является одним из лучших вариантов для проектирования баз знаний.

## Список источников:
[1] Michael Genfond, Nicola Leone - "Artificial Intellegence - Logic programming and knowledge representation—The A-Prolog perspective".
https://core.ac.uk/download/pdf/82361089.pdf

[2] David B.Searls, Lewis M.Norton - "Logic-based configuration with a semantic network"
https://core.ac.uk/download/pdf/82199796.pdf

[3] Dennis Merritt  - "Building Expert Systems in Prolog"  https://www.amzi.com/distribution/files/xsip_book.pdf

[4] Giuseppe Bonaccorso - "Machine Learning Algorithms"



